# OIDC_BingYan

>2024冰岩作坊后端实习题OIDC。

**注：每天的记录都是按照实现顺序一步步来的，也就是说有可能出现对于一个任务的框架建立和具体实现在两个地方的情况。**

## 工作情况大汇总

### 最后的完成情况

全部完成六个阶段的基础要求和提升要求。**在此基础上加入了一些没有要求的新功能**。

### 任务要求汇总

1. 阶段一
   1. 用户登录
   2. 用户注册
   3. 用户修改信息
   4. 用户信息包括
      1. 用户名
      2. 密码
      3. 邮箱
      4. 昵称
      5. 头像
      6. 简介
   5. 发邮件点击注册才能注册成功
   6. 邮箱验证码五分钟内只能获取一次
2. 阶段二
   1. 用户授权
   2. 给予code
   3. 通过code颁发access token
   4. 通过token交换信息
3. 阶段三
   1. 通过refresh token获取新令牌
   2. State防止跨站攻击
   3. 检测回调地址是否一致
4. 阶段四
   1. 立足于阶段二三实现身分层，返回IDToken，这样就不用再验证身份了
5. 阶段五
   1. 收藏番剧
      1. 五种状态
      2. 发表评论和吐槽
      3. 给予评分
   2. 番剧信息包括
      1. 番剧名
      2. 番剧简介
      3. 番剧导演
   3. 查看和搜索自己的追番
   4. 添加好友
   5. 看到好友的追番和评价等等
6. 阶段六
   1. 实现一个OAuth2.0 的客户端于bangumi交接。
   2. 加入state防止跨站攻击。

如上所述，我实现了上述所有功能，并且加入了一些没有要求的新功能。

### 额外拓展功能汇总

在全局项目中都用logger记录可能出现的极端情况，输出到控制台和文件中。

1. 阶段一
   1. 用户头像上传，头像会上传到图床上，储存链接。
   2. 用户头像修改，头像会修改到图床上，储存链接。
   3. 用户信息修改，头像和简介为非必需，如果用户不提供就用默认值替代。
   4. 用户登录是通过储存在上下文实现的，不能登录就只能前往登录和注册两个网址，通过储存在上下文里，只要在请求头里加入token，就能访问你能访问的地方。
2. 阶段二
   1. 客户端注册
      1. 事实上这种小项目的客户端注册手动写道数据库里就完事了，但是一点都不优雅，于是秉承着完美主义我写了一个注册接口，提供回调地址和邮箱，和用户注册一样，我会向邮箱发信息，你点击激活了才算注册哦
      2. id和密码是我写的一个随机生成高强度的id和密码的函数生成的
   2. 写了接口判断URL是否正确，防止浑水摸鱼
   3. 实现用户授权多样化授权
      1. 是否授权昵称
      2. 是否授权邮件
      3. 是否授权头像
      4. 是否授权介绍
3. 阶段三
   1. 自动通过refresh token获取新令牌
      1. 如果两个都过期了，那么就在登陆一次吧
4. 阶段四
   1. 无
5. 阶段五
   1. 注册管理员
      1. 可以注册为管理员管理各项事务
   2. 管理员上传番剧
   3. 管理员上传新的交互状态
      1. 如果觉得现有的五个状态不够用，可以让管理员上传，这样更加灵活。
   4. 实现tag功能
      1. 在要求里明确说了tag不是必须要求，但写了总不是坏事
      2. 管理员可以上传tag
      3. 用户可以添加tag
   5. 番剧中加入URL指向看番链接
   6. 模糊搜索动漫
   7. 判断是否已经追番，如果已经追番了，那么就不允许再追番
      1. 但是可以修改自己的追番信息！
   8. 模糊搜索用户
   9. 加入删除好友功能
      1. 删除了自然也就不能看到你的追番信息了。
6. 阶段六
   1. 无

### 总结

这次实习，我用了整整一周的课余时间，基本上只要有时间就在学习实习相关的东西，写实习的代码和文档等等。

坦白来讲，这是我差不多写过最大，框架最严谨的项目了。

也让我认识到还有很多不足。例如：我还不是很了解在代码的哪些地方可能会发生安全事故，或者出现了安全问题我该怎么处理。

这些都是今后要一点点补充的。

但是这个项目作为我的起步项目，我想我尽了全力。

谢谢你看我的文档和代码。

## 代码结构框架

### 项目结构框架

参考并细化了MVC（Model-View-Controller）模型。我采用了以下层次结构以确保每个组件的职责都被清晰定义且互相独立：

1. **POJO（Plain Old Java Object）**
   - 定义了与数据库表对应的实体类，用于映射表中的记录。这些类仅包含属性和其getter和setter方法，还有对应的有参无参构造函数，以及hashcode和equals函数。
   - 由于不让用第三方库，所以我本想用lombok来自动注解的愿望破灭了，遂手敲了这些方法，对标@Data,@NoArgsConstructor,@AllArgsConstructor这些注解。
   - 无任何业务逻辑，确保了数据的简单传递。
2. **Model**
   - 在我的架构中，Model为数据传输对象（DTO），用于封装客户端请求的数据。
   - 这使得传统的MVC更加细化，将业务逻辑与数据访问解耦，确保了代码的清晰性和可维护性。
   - 同时，DTO可以用于在服务之间传递数据，确保了数据的一致性和安全性。
3. **Mapper**
   - 这是数据访问层，Mapper接口定义了与数据库交互的方法，如查询、插入、更新和删除。这些方法由MyBatis-Plus动态实现，确保了数据库操作的一致性和高效性。
4. **Service**
   - 业务逻辑层封装了具体的业务操作，依赖于Mapper层进行数据访问。Service层的设计使得业务逻辑与数据访问代码解耦，便于维护和测试。
   - 在这一层中，我把每个业务逻辑都对应一个接口及其实现，这让我的代码十分灵活，可以针对同一个接口做出不同的实现，根据不同的情况进行选择，进而实现更复杂的业务逻辑。
5. **Controller**
   - 作为应用程序的表现层，Controller负责处理外部请求，调用Service层的业务方法，并返回相应的视图或数据。这确保了前端请求的处理逻辑与后端业务逻辑的分离，增强了应用程序的灵活性和可扩展性。

这样的架构遵循了MVC的基本原则，还通过更细致的分层增加了代码的可读性和可维护性。每层的定义清晰，职责单一。

#### 参考了MVC的方面

1. **Controller层**
   - Controller层在扮演着和MVC中相同的角色，即处理用户请求、调用后端服务并返回响应。这一层作为用户交互和后端服务之间的桥梁。
2. **Model的使用**
   - 本项目的Model层用于封装复杂请求体的数据，这在某种程度上对应于MVC中的Model概念，即作为数据和业务规则的承载体。但是在我的项目中，Model侧重于数据传输对象（DTO），这仍然体现了Model在数据处理中的核心作用。

#### 细化了MVC的方面

1. **POJO和Model的区分**
   - 我的架构中明确区分了POJO（用于数据库映射）和Model（用于封装请求数据）。
   - 在传统MVC中，Model通常既包含业务数据也包含业务逻辑，而在我的项目中，POJO专注于与数据库表的映射，而Model则专门用于处理请求数据，这使得数据层更加清晰。
2. **引入Mapper层**
   - Mapper层作为数据访问层处理数据库交互，这一层在标准的MVC模型中通常不会单独区分出来。
   - 通过引入Mapper层，项目能够更加灵活地处理数据库操作，同时降低了Service层与数据库之间的耦合度。
3. **Service层的设立**
   - 在传统的MVC模型中，业务逻辑可能直接放在Controller或Model中。
   - 我的架构中，Service层专门负责业务逻辑的处理，这不仅使得业务逻辑更加模块化，也进一步减轻了Controller层的负担，让Controller层更加专注于处理请求和返回响应。

通过这些参考和细化，我保留了MVC模型的核心优点，还通过更加精细化的层次划分，提高了项目的可维护性和可扩展性。

### 阶段一框架

这一阶段的任务是写所有有关用户的代码，包括用户注册，用户登录，用户信息修改，用户头像修改，用户头像上传。

#### 阶段一详细功能说明

1. 用jwt实现Spring Security的认证和授权
2. 实现用户登录
   1. 用用户名和密码登录。
   2. 登录成功返回token。
3. 实现用户注册
   1. 需要提供用户名，密码，邮箱，昵称，头像，简介，头像和简介为非必需，如果用户不提供就用默认值替代。
   2. 头像是扔到图床上，储存链接。
   3. 注册成功后，自动发送一封邮件到用户邮箱，要求用户点击邮件中的链接来激活账号。激活成功才算注册完成，可以正常登录，否则等同于完全没有注册，这符合事务的基本原则，要么全做，要么不做。
   4. 由于我们允许一个邮箱注册多个账号，所以是每个邮箱**五分钟**只能获取一次邮件。
4. 实现用户信息获取
   1. 获取用户信息，需要提供token。
   2. 获取信息不包括密码。
5. 实现用户信息修改
   1. 支持修改的信息包括：昵称，头像，简介，密码。
   2. 登录的用户才能修改自己的信息。
6. 注明
   1. 用户登录是通过储存在上下文实现的，不能登录就只能前往登录和注册两个网址，通过储存在上下文里，只要在请求头里加入token，就能访问你能访问的地方。

#### 阶段一代码框架

代码框架是基于整个项目的代码框架设计的。

1. POJO
   1. User类：用于封装用户信息，包括ID、用户名、密码、邮箱、昵称、头像、简介、是否激活、激活令牌、最后一次邮件发送时间，用于与数据库表进行映射。包括一堆的Setter，Getter，hashCode,toString,equals方法。
2. Model
   1. UserRegistrationModel类：用于封装用户注册请求的数据，包括用户名、密码、重复密码、邮箱、昵称、头像、简介。
   2. ImageModel类：用于封装所有图片请求体的数据。
3. Mapper
   1. UserMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
4. Service
   1. interfaces
      1. tools
         1. ImageUploadService接口：用于处理图片上传的逻辑。这个接口的不同实现可以完成不同的图片上传逻辑。
      2. user
         1. account
            1. InfoService接口：用于处理和用户信息有关的各种逻辑，包括获取和更新。
            2. LoginService接口：用于处理用户登录的逻辑。
            3. RegisterService接口：用于处理用户注册的逻辑，其中还包括注册时的邮件发送业务。
   2. impl
      1. LoadByUser
         1. UserDetailsServiceImpl类：实现了UserDetailsService接口，其中loadUserByUsername函数用于根据用户名和密码进行登录验证。
      2. tools
         1. ImageUploadServiceImpl类：实现了ImageUploadService接口，其中uploadImage函数用于上传图片。
         2. JwtAuthenticationTokenFilter类：实现了Filter接口，用于对每个请求进行过滤，并验证token的有效性。
         3. JwtTool类：用于生成和解析JWT。
         4. UserDetailImpl类：实现了UserDetails接口，用于封装用户信息，并实现与数据库表的映射。
      3. User
         1. account
            1. InfoServiceImpl：实现了InfoService接口。其中包括很多信息的更新和获取。
            2. LoginServiceImpl类：实现了LoginService接口。其中包括了登录的逻辑。
            3. RegisterServiceImpl类：实现了RegisterService接口。其中包括了注册的逻辑和邮件发送业务。
5. Controller
   1. user
      1. account
         1. InfoController类：用于处理与用户信息有关的各种请求，包括获取和更新。
         2. LoginController类：用于处理用户登录的请求。
         3. RegisterController类：用于处理用户注册的请求。
6. config
   1. SecurityConfig类：用于配置Spring Security的相关设置。

### 阶段二和阶段三框架

阶段二和阶段三的目的都是实现一个尽可能完备的OAuth2.0功能，所以我在这里一起说了。

**由于要手搓这样一个系统，而我之前也没有接触过这类东西，而且网上也没有任何实现的教程，所以我做的有瑕疵还请多多包涵。**

#### 阶段二三详细功能说明

1. 实现客户端注册
   1. 事实上这种小项目的客户端注册手动写道数据库里就完事了，但是一点都不优雅，于是秉承着完美主义我写了一个注册接口，提供回调地址和邮箱，和用户注册一样，我会向邮箱发信息，你点击激活了才算注册哦
   2. 邮箱功能还是一样一个邮箱号五分钟一次
   3. id和密码是我写的一个随机生成高强度的id和密码的函数生成的
   4. id和密码会通过邮件发送过去
   5. 我写了接口判断URL是否有效，防止浑水摸鱼
2. 实现客户端认证
   1. 这部分的接口其实就是用户申请OAuth2.0服务的时候会跳转的接口
   2. 毕竟我们要先验证一下客户端是否可信，才能进行下一步，所以这一步就是我们开始OAuth2.0服务的第一步
   3. 客户端需要给我它的id密码和回调
   4. 和之前一样经过一系列什么非空判断啊长度判断什么什么的，判断一下这个客户端是否受信赖
   5. 如果是注册过的，我才允许跳转到授权页面
3. 实现用户授权
   1. 搞了个表专门储存授权码
   2. 别担心，授权码用完了就会被删掉
   3. 建立了授权码对应的pojo和mapper
   4. 这样授权码可以保存
      1. 授权码本身内容
      2. 是否授权昵称
      3. 是否授权邮件
      4. 是否授权头像
      5. 是否授权介绍
      6. 用户id
   5. 是的！你没听错我实现了让用户选择共享什么信息的功能，这样在通过我们账号登录的同时还可以选择授权内容
   6. 当然还有很多细节要处理，比如如果两个令牌都到期了要让用户输入密码和用户名验证身份之类的
   7. 最最重要的是，你必须给我一个state，我会原封不动的还给你，防止有坏蛋搞CSRF。
   8. 更多细节就不多说了，去代码里看吧！
4. 实现根据授权码获取token
   1. 这部分无疑是核心功能，我也是煞费苦心啊，由于我之前就学过jwt的内容，接触过刷新令牌这些东西，于是我把阶段二和阶段三一起写了
   2. 客户端通过前面的过程后会拿着授权码和它的id密码回调地址来申请两个令牌
   3. 如果id密码回调都没错，那么我会根据这个授权码来生成两个包含claims的jwt，这样的好处是我可以解析jwt知道有什么权限。
   4. 然后删除这个该死的（物理）授权码
   5. 于是我返回这两个令牌给客户端
   6. 下一次就拿着这两个令牌找我吧！
5. 通过token获取信息
   1. 客户端拿着两个令牌来找我，我会先判断是不是jwt以及有没有过期，如果access过期了，那么用refresh在搞一个，如果两个都过期了，那么就在登陆一次吧。。。。
   2. 值得一提的是access有效期五分钟，refresh有效期14天。
   3. 如果上面的过程走完了，那么我会开始解析jwt返回授权了的信息
6. 至此，OAuth2.0的一个简易过程就走完了，事实上我以及尽可能注意了**安全问题**，例如，在发送token的时候我要求在请求头里发，避免被窃取等等，但是我也没有太多的后端开发经验，确实不知道还有哪里有安全问题。

#### 阶段二三代码架构

1. POJO
   1. Client类：用于封装客户端信息，包括ID、密码、回调地址。包括一堆的Setter，Getter，hashCode,toString,equals方法。
   2. AuthoriazationCOde类：用于封装授权码信息，包括授权码、是否授权昵称、是否授权邮件、是否授权头像、是否授权简介、用户ID。包括一堆的Setter，Getter，hashCode,toString,equals方法。
      1. 这个类每次只能被用一次，然后被使用了就堂堂删掉。
2. Model
   1. 这两个阶段没有新增Model
3. Mapper
   1. ClientMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   2. AuthorizationCodeMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
4. Service
   1. interfaces
      1. client
         1. ClientRegisterService接口：用于处理客户端注册的逻辑。
      2. oauth
         1. AuthorizationCodeService接口：用于处理授权码的逻辑。包括生成处理储存返回授权码等等。
         2. GetInfoByTokenService接口：用于处理根据token获取用户信息的逻辑。
         3. GetTokenByTokenService接口：用于处理根据refreshToken获取accessToken的逻辑。
         4. TokenByCodeService接口：用于处理根据授权码获取token的逻辑。
         5. VerifyClientService接口：用于处理验证客户端是否可信的逻辑。
      3. tools
         1. CredentialService接口：用于处理生成随机高强度id和密码的逻辑。
         2. UrlValidationService接口：用于处理验证URL是否有效的逻辑。
   2. impl
      1. client
         1. ClientRegisterServiceImpl类：实现了ClientRegisterService接口。其中包括了客户端注册的逻辑。
      2. oauth
         1. AuthorizationCodeServiceImpl类：实现了AuthorizationCodeService接口。其中包括了授权码的逻辑。
         2. GetInfoByTokenServiceImpl类：实现了GetInfoByTokenService接口。其中包括了根据token获取用户信息的逻辑。
         3. GetTokenByTokenServiceImpl类：实现了GetTokenByTokenService接口。其中包括了根据refreshToken获取accessToken的逻辑。
         4. TokenByCodeServiceImpl类：实现了TokenByCodeService接口。其中包括了根据授权码获取token的逻辑。
         5. VerifyClientServiceImpl类：实现了VerifyClientService接口。其中包括了验证客户端是否可信的逻辑。
      3. tools
         1. CredentialServiceImpl类：实现了CredentialService接口。其中包括了生成随机高强度id和密码的逻辑。
         2. UrlValidationServiceImpl类：实现了UrlValidationService接口。其中包括了验证URL是否有效的逻辑。
5. Controller
   1. client
      1. ClientRegisterController类：用于处理客户端注册的请求。
   2. oauth
      1. AuthorizationCodeController类：用于处理授权码的请求。
      2. GetInfoByTokenController类：用于处理根据token获取用户信息的请求。
      3. TokenByCodeController类：用于处理根据授权码获取token的请求。
      4. VerifyClientController类：用于处理验证客户端是否可信的请求。

### 阶段四框架

#### 阶段四详细功能说明

在原先OAuth2.0的基础上加入了身份层，不是直接返回信息了，现在返回IDToken，信息都包含其中。

#### 阶段四代码架构

1. Service
   1. interface
      1. GetIDTokenByTokenService接口：用于处理返回idtoken的情况。
   2. impl
      1. GetIDTokenByTokenServiceImpl类：实现处理返回idtoken的逻辑。

### 阶段五框架

#### 阶段五详细功能说明

1. 实现注册管理员功能
   1. 管理员可以上传动漫，标签，和交互状态。
   2. 这样设计可以动态管理动漫，标签和交互状态。
2. 实现通过id获取动漫的详细信息
   1. 这个详细信息包括动漫本身的各种信息，和当前用户与其的交互状态，是否追番，追番了的评价，标签，打分，状态等等。
   2. 再后续的实现中还支持返回所有好友的相关状态。
3. 实现搜索动漫功能
   1. 这里用了模糊搜索
   2. 比如你搜索“迷”，就会出现“迷宫饭”（迷宫饭真好看）。
4. 实现获得所有当前的标签和状态的接口
   1. 用户从里面选择标签和状态
5. 实现追番功能
   1. 用户提供状态，打分，评论和标签，对某部动漫进行追番。
   2. 只有状态是必须的。
6. 实现查看是否已经追番的接口
   1. 可以查看是否已经追番，并且可以查看是否已经评价。
7. 实现获得所有追番的信息的接口
   1. 用户可以查看自己所有追番的动漫的信息。
8. 实现模糊查找用户的功能
9. 实现查看某个用户所有追番信息的功能
   1. 只有好友能查看
10. 实现发送好友请求的功能
11. 实现处理好友请求、查看所有好友请求的功能
    1. 可以查看所有的好友请求，并一一处理
12. 实现删除好友的功能
13. 实现获取好友列表的功能

#### 阶段五代码架构

1. pojo
   1. Anime: 动漫类，用于和动漫表交互。
   2. AnimeTag: 动漫标签类，用于和标签表交互。
   3. UserAnimeState: 动漫状态类，用于和状态表交互。
   4. UserAnime: 用户动漫类，用于和用户动漫表交互。追番信息什么的.
   5. FriendRequest: 好友请求类，用于和好友请求表交互。
   6. Friends: 好友类，用于和好友表交互。
2. Mapper
   1. AnimeMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   2. AnimeTagMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   3. UserAnimeStateMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   4. UserAnimeMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   5. FriendRequestMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   6. FriendsMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
3. Model
   1. UserInfoModel: 用户信息模型类，用于封装用户信息。
   2. UserAnimeModel: 用户动漫模型类，用于封装用户动漫信息。
4. Service
   1. interface
      1. anime
         1. add
            1. AnimeAddService: 实现添加动漫的逻辑。
         2. info
            1. GetInfoService: 实现获取动漫详细信息的逻辑。
         3. search
            1. SearchAnimeService: 实现搜索动漫的逻辑。
         4. status
            1. AddNewStatusService: 实现添加新的状态的逻辑。
         5. tags
            1. AddNewTagService: 实现添加新的标签的逻辑。
      2. user
         1. anime
            1. GetFollowedAnimeByIdService: 实现根据用户id获取用户所有追番的动漫的逻辑。
            2. GetFollowedAnimeService: 实现根据当前用户获取用户所有追番的动漫的逻辑。
         2. friend
            1. AddNewFriendService: 实现添加新的好友的逻辑，处理好友请求，查看请求列表也在这里。
            2. DeleteFriendService: 实现删除好友的逻辑。
            3. GetFriendsInfoService: 实现获取所有好友信息的逻辑。
         3. search
            1. SearchUserService: 实现搜索用户信息的逻辑。
      3. user_anime
         1. AddInfoToUserAnimeService: 实现添加用户动漫信息的逻辑。
         2. GetTagsAndStatusService: 实现获取用户动漫的标签和状态的逻辑。
         3. IfAleadyFollowService: 实现判断用户是否已经追番的逻辑。
   2. impl
      1. anime
         1. add
            1. AnimeAddServiceImpl类：实现添加动漫的逻辑。
         2. info
            1. GetInfoServiceImpl类：实现获取动漫详细信息的逻辑。
         3. search
            1. SearchAnimeServiceImpl类：实现搜索动漫的逻辑。
         4. status
            1. AddNewStatusServiceImpl类：实现添加新的状态的逻辑。
         5. tags
            1. AddNewTagServiceImpl类：实现添加新的标签的逻辑。
      2. user
         1. anime
            1. GetFollowedAnimeByIdServiceImpl类：实现根据用户id获取用户所有追番的动漫的逻辑。
            2. GetFollowedAnimeServiceImpl类：实现根据当前用户获取用户所有追番的动漫的逻辑。
         2. friend
            1. AddNewFriendServiceImpl类：实现添加新的好友的逻辑，处理好友请求，查看请求列表也在这里。
            2. DeleteFriendServiceImpl类：实现删除好友的逻辑。
            3. GetFriendsInfoServiceImpl类：实现获取所有好友信息的逻辑。
         3. search
            1. SearchUserServiceImpl类：实现搜索用户信息的逻辑。
      3. user_anime
         1. AddInfoToUserAnimeServiceImpl类：实现添加用户动漫信息的逻辑。
         2. GetTagsAndStatusServiceImpl类：实现获取用户动漫的标签和状态的逻辑。
         3. IfAleadyFollowServiceImpl类：实现判断用户是否已经追番的逻辑。
5. Controller
   1. anime
      1. add
         1. AnimeAddController类：实现添加动漫的请求。
      2. info
         1. GetInfoController类：实现获取动漫详细信息的请求。
      3. search
         1. SearchAnimeController类：实现搜索动漫的请求。
      4. status
         1. AddNewStatusController类：实现添加新的状态的请求。
      5. tags
         1. AddNewTagController类：实现添加新的标签的请求。
   2. user
      1. anime
         1. GetFollowedAnimeByIdController类：实现根据用户id获取用户所有追番的动漫的请求。
         2. GetFollowedAnimeController类：实现根据当前用户获取用户所有追番的动漫的请求。
      2. friend
         1. AddNewFriendController类：实现添加新的好友的请求，处理好友请求，查看请求列表也在这里。
         2. DeleteFriendController类：实现删除好友的请求。
         3. GetFriendsInfoController类：实现获取所有好友信息的请求。
      3. search
         1. SearchUserController类：实现搜索用户信息的请求。
   3. user_anime
      1. AddInfoToUserAnimeController类：实现添加用户动漫信息的请求。
      2. GetTagsAndStatusController类：实现获取用户动漫的标签和状态的请求。
      3. IfAleadyFollowController类：实现判断用户是否已经追番的请求。

### 阶段六框架

#### 阶段六详细功能说明

实际上阶段6就是一个OAuth的客户端，我负责直接跳转到官方网站，授权后给我一个code，然后我用code获取token，拿到html，解析信息就行了。

#### 阶段六代码架构

1. pojo
   1. Bangumi: 存放两个token的表的交互类。
   2. State: 存放State的表的交互类。
2. mapper
   1. BangumiMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
   2. StateMapper类：定义了与数据库表对应的Mapper接口，用于实现与数据库表的交互操作。
3. Service
   1. interface
      1. bangumi
         1. AuthorizeService: 实现获取授权码的逻辑。
         2. GetTokenService: 实现获取两个Token的逻辑。
         3. GetBangumiInfoService: 实现获取用户信息的逻辑。
   2. Impl
      1. bangumi
         1. AuthorizeServiceImpl类：实现获取授权码的逻辑。
         2. GetTokenServiceImpl类：实现获取两个Token的逻辑。
         3. GetBangumiInfoServiceImpl类：实现获取用户信息的逻辑。
4. Controller
   1. bangumi
      1. AuthorizeController类：实现获取授权码的请求。
      2. GetTokenController类：实现获取两个Token的请求。
      3. GetBangumiInfoController类：实现获取用户信息的请求。

## 24.3.23任务梳理

### 新建文件夹（）

创建一个springboot项目，名称为OIDC。

采用版本为JDK1.8，Java8，SpringBoot2.6.13。

### 引入依赖

引入各种依赖来配置环境，具体可见readme。

### 配置数据库与数据源

数据库采用MySql。

用户表内容包括：

|           名称            |                       评论                       |   数据类型    | 非null |
| :-----------------------: | :----------------------------------------------: | :-----------: | :----: |
|            id             | 用户id，手动自增，非空，主键，唯一，不允许修改。 |      int      |  true  |
|         user_name         |   用户名，非空，唯一，不允许修改，最多100字。    | varchar(100)  |  true  |
|       user_password       |        密码，非空，允许修改，最多1000字。        | varchar(1000) |  true  |
|       user_nickname       |         昵称，非空，允许修改，最多20字。         |  varchar(20)  |  true  |
|        user_email         |       邮箱，非空，不允许修改，最多100字。        | varchar(100)  |  true  |
|        user_avatar        |   头像，非空（有默认），允许修改，最多100字。    | varchar(100)  |  true  |
|     user_introduction     |   介绍，非空（有默认），允许修改，最多1000字。   | varchar(1000) |  true  |
|      user_is_active       |              用于判断用户是否激活。              |  tinyint(1)   |  true  |
|  user_confirmation_token  |                用户唯一激活令牌。                | varchar(1000) | false  |
| user_last_email_sent_time |         用户邮箱最后一次申请邮件的时间。         |   datetime    | false  |

### 引入Spring Security

经过实现UserDetailsService和UserDetails接口，实现通过用户密码认证和授权。

#### 认证流程

实际上这里是的依据是Spring提供的一套用户认证流程：

UserDetails接口定义了Spring Security用于认证和授权的用户信息的基本属性，包括用户名、密码、账户是否过期、账户是否锁定等。实现这个接口意味着提供了一种方式来封装用户信息，使其能够被Spring Security使用。

UserDetailsService接口定义了一个方法loadUserByUsername，这个方法负责根据用户名查找用户，并返回一个UserDetails对象。在用户登录时，Spring Security会调用这个方法来获取用户的详细信息。

当用户尝试登录时，Spring Security的认证机制会自动调用loadUserByUsername方法来查找用户。找到用户后，框架比较用户输入的密码和数据库中存储的密码。如果密码匹配，用户被认为是合法的，认证成功，将这个用户存在上下文中，用户随后就可以访问允许的资源啦。

这一过程是通过Spring Security的AuthenticationManager来完成的，其中DaoAuthenticationProvider使用UserDetailsService来获取用户信息，并使用配置的PasswordEncoder来比较密码。

我的PasswordEncoder采用BCryptPasswordEncoder。

果咩啊。。。。。写完这部分，进行测试的时候发现不小心死锁了。。。。但是我又不想直接手动往数据库插入数据。。。有点太不优雅了。。。只能先写注册了嗯。

#### 实现从sessionId到JWT

覆盖WebSecurityConfigurerAdapter类方法来自定义spring security配置。

禁用CSRF保护，我们有token验证

设置session为无状态，jwt不需要这个

允许跨域预检请求

开放几个公开接口来注册登录

参考资料：<https://spring.io/guides/gs/securing-web>

值得一提的是，我在查资料的时候，发现从 Spring Security 5.7.0 版本开始，WebSecurityConfigurerAdapter 被标记为已弃用。推荐的做法是转向基于组件的安全配置。

这在这篇文章中详细叙述了：<https://www.javaguides.net/2022/08/spring-security-without-webSecurityconfigureradapter.html>

##### 实现JWT工具

1. **生成密钥** (`generalKey` 方法)：
   - 将一个预定义的字符串（JWT_KEY）通过 Base64 解码为字节数组。
   - 使用这个字节数组创建一个 `SecretKey` 对象，用于 JWT 的签名和验证。
2. **生成 JWT** (`createJWT` 方法)：
   - 调用 `getUUID` 方法生成一个唯一标识符（UUID）。
   - 调用 `getJwtBuilder` 方法创建一个 `JwtBuilder` 对象，设置 JWT 的主题（subject）、发行者（issuer）、签发时间（issuedAt）、过期时间（expiration）等。
   - 使用生成的 `SecretKey` 对 JWT 进行签名。
   - 调用 `compact` 方法将 JWT 对象压缩成一个字符串，这个字符串就是最终的 JWT。
3. **解析 JWT** (`parseJWT` 方法)：
   - 调用 `generalKey` 方法生成 `SecretKey` 对象。
   - 使用 `Jwts.parser().verifyWith(secretKey)` 来验证 JWT 的签名是否有效。
   - 解析 JWT 字符串，获取 JWT 的负载（payload），这里主要是 `Claims` 对象，其中包含了 JWT 的信息，如主题、签发者等。

##### 实现JWT拦截器

提取 JWT：从 HTTP 请求的 Authorization 头部提取 JWT。如果请求头不存在或不是以 "Bearer " 开头，则直接放行（即不进行 JWT 验证）。

JWT 解析：使用 JwtTool.parseJWT(token) 方法尝试解析 JWT。如果解析失败（比如，JWT 无效或过期），抛出异常。

用户验证：通过 JWT 中的主题查询用户信息。如果查询不到用户，表示用户不存在或未登录，抛出异常。

认证信息设置：使用查询到的用户信息创建 UsernamePasswordAuthenticationToken，并将其设置到 SecurityContextHolder 中。这样，后续的处理流程就可以认为该请求已经通过身份验证。

请求放行。

参考资料：<https://blog.csdn.net/weixin_46195957/article/details/115326648>

### 实现登录

采用AuthenticationManager处理认证。

用UsernamePasswordAuthenticationToken封装用户名和密码。

用AuthenticationManager.authenticate(authenticationToken)进行认证，认证失败自己报错。这部分逻辑我在上面的Security部分也说过了，就是SpringBoot的一个认证流程。

认证成功后，生成token，并返回给前端。

### 实现注册

注册需要7个值：

1. 用户名
2. 密码
3. 确认密码
4. 邮箱
5. 昵称
6. 头像
7. 简介

头像为头像简介，目前用的是手动上传的图床图像，后续会编写一个上传头像的接口。

如果上传的7个值满足一定要求就注册然后插入就完了。

这部分需要处理的细节很多，包括但不限于是否输入，不输入是否有默认值，长度限制等等。理论上这部分还应该有敏感内容的判定，但是这部分要调用付费的外部api，所以先不考虑。

测试：终于解决了死锁问题，postman启动！测试过程很顺利，代码可以根据不同的错误返回不同的错误信息。例如没有用户名就说用户名不能为空（只写空格也不行）。但是bug也随之出现。

### 出现bug，开修

什么！为什么我的MySql不能正常的让我的id自增！？！？

明明已经设置了id自增，唯一，且为主键。

代码逻辑也没问题。。。

尝试直接在cmd里插入一个值，居然是正常的！！

可能跟spring boot的版本有关，之前写的项目就没这样的错误！

没事我直接手动自增就好了。。。。笨但是管用的办法。。。。

### 24.3.23总结

今天新建了文件夹，配置了各项依赖，调整了数据库，大概写了一下用户的登录，注册模块，修复了bug。。。嗯，明天开始正式的OIDC。。。。

## 24.3.24任务梳理

>说是24号，其实是23号晚上，今晚要熬夜了嗯。。。

### 手敲USER

把之前直接注入的User类改写为手动new的User类。

### 头像上传（调试）

使用图床API上传图片，仍在调试中

测试：本来想直接写成一个Controller的，但是发现上传头像的逻辑和注册的逻辑有重叠，所以就直接写成了一个Service的。浪费了很多时间，请大家下次动手之前先想好逻辑，引以为鉴，望周知（bushi）。

### 邮箱发送（调试）

利用两个属性来判断一个用户是否激活来实现发送邮件注册，仍在调试中。

### 邮箱发送（实现）

嗯，完成了邮箱验证功能，还需要完善限制频率的功能。

测试：新注册了一个网易163邮箱，通过Postman发送注册请求，成功向我的个人邮箱发送激活邮件。在不同情况下，用不同的数据测试，发送了30多封邮件，都成功了。

### 完善限制频率功能，每五分钟一次（完善）

在发送邮件的接口上加上一个时间限制，限制发送邮件的频率。通过更改逻辑，完美实现了这个功能，限制注册用户只要还没激活，就可以每五分钟发送一次邮件，不会出现只能发送一次，再发送就显示用户名重复的情况。

**注：因为我们允许一个邮箱注册多个账号，所以是每个邮箱五分钟一次。**

（2024.3.24凌晨4点05分）今日份结束，睡醒继续。

**时间：今天花了8个小时。**

### 重写登录逻辑

现在必须激活才能登陆。

### 修改部分逻辑

减少字段注入，确保依赖项不会被后续更改，使得类更加不可变，从而增加了代码的稳定性和可靠性。

### 获取用户信息

实现根据token获取用户信息的功能。token写在请求头里，被过滤器拦截后，使用JWT工具解析token，获取用户信息，储存在SecurityContextHolder中，后续在Service中使用SecurityContextHolder获取用户信息。

### 实现用户信息修改

实现根据token修改用户信息的功能。可以修改的有昵称，头像（还没实现），简介，密码。

### 实现用户头像自主上传

图床选择ImgTP，借用api实现图片上传。终于！！！！！！！！！！！！！！！！！！！！！！！

图床API：<https://www.imgtp.com/index/api.html>

### 实现用户头像更改

实现根据token更改用户头像的功能。

### 24.3.24总结

今天彻底完成阶段一，明天正式开始OIDC，希望不会太难。

而且今天在导师的指导下，学会了规范的分支命名和commit提交。。。

对不起我之前这部分做的太烂。。

今天做的具体的事情都在上面，我这里就不过多赘述了。

**时间：今天花了6个小时。**

## 24.3.25任务梳理

### 重写worklog

在工作日志中详细记录我的思路框架和参考的合理架构。

### 自学OAuth 2.0

仔细研读任务书，然后在全网大幅度搜索相关知识，

部分参考资料如下：

<[什么是OAuth 2.0？深度解析OAuth 2.0的工作原理和应用场景-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2355222)>

<[OAuth 2.0 — OAuth](https://oauth.net/2/)>

<[What is OAuth 2.0 and what does it do for you? - Auth0](https://auth0.com/intro-to-iam/what-is-oauth-2)>

大概流程如下：

1. **用户请求登录**：用户在客户端（第三方应用）请求使用我们网站的身份进行登录。
2. **重定向到认证服务器**：客户端将用户重定向到我们的认证服务器的登录页面，用户在此输入账号和密码，并选择是否授权登录。
3. **用户授权**：一旦用户授权登录，认证服务器生成一个授权码，并将授权码通过重定向URL返回给客户端。这个授权码是短暂有效的，并且只能使用一次。
4. **客户端请求访问令牌**：客户端拿到授权码后，向认证服务器请求访问令牌（和刷新令牌）。在这一步，客户端会发送授权码以及自己的认证信息给认证服务器。
5. **认证服务器验证授权码**：认证服务器验证授权码的有效性和客户端的认证信息。如果验证通过，认证服务器将返回包含访问令牌和刷新令牌的响应。这些令牌通常是JWT格式的。
6. **使用访问令牌访问资源**：客户端使用访问令牌请求资源服务器上的受保护资源。资源服务器需要验证访问令牌的有效性。
7. **刷新访问令牌**：当访问令牌接近过期或已过期时，客户端可以使用刷新令牌向认证服务器请求新的访问令牌。这样可以在不需要用户重新登录的情况下继续访问资源。
8. **访问令牌和刷新令牌的周期**：访问令牌通常具有较短的有效期，而刷新令牌具有较长的有效期。当刷新令牌也过期时，用户需要重新通过登录和授权流程获取新的令牌。

### 查询如何实现使用Authorization Code模式的OAuth2.0服务的功能

惊奇的发现spring boot的spring security中有对应的模块，欣喜若狂遂进行依赖配置，配置了一下午，一直报错，现已查明原因，在spring security5.0以后的版本中不再支持项目中内置的认证服务器只能用第三方服务。

此时的我被折磨了一下午非常暴躁，遂翘课继续死磕，后续心态爆炸决定手搓一个这样的服务，但转念一想，或许题目本来就是想让我这么做，询问老师后果然如此。。。白白浪费一下午。。。我真的喷喷的。

### 实现客户端的注册功能

由于我们只给受信赖的客户端提供服务，所以开放客户端注册是很不错的选择，不过更简单的方式是直接手动输入，但是我觉得那不够优雅，完美主义驱使我写了一个完整的客户端注册逻辑，经过严格的数据审查（判断回调链接是否有效等）后才能被注册，同样需要邮件验证，并且允许一个邮箱注册多个客户端，但是一个回调链接只能对应一个客户端。注册后，随机生成id和密码储存在数据库，并通过邮件发给客户端，这样下次申请服务的时候带上id和密码就可以了，无需再给我回调函数。

### 集成日志功能

再项目中集成logback和SLF4J来记录项目的运行情况，输出到控制台并且保存到文件，采用自动滚动（即在达到特定大小或日期变化时创建新的日志文件），保持单个日志文件的大小在合理范围内，同时也能自动清理旧的日志文件，避免无限制地消耗磁盘空间。设置保留最近30天的日志文件。定义了每个日志文件的最大大小，超过这个大小时，将创建新的日志文件。保存在./log/app.log中。

### 24.3.25总结

今天本来可以做更多事情的，但是耽误了一下午时间，实在是得不偿失。。。。流下了懊悔的泪水。。。。

**时间：今天花了10个小时（浪费了5个小时，1.5个小时学习理论，2个小时实现各种功能，1.5个小时重写日志和编写新日志）。**

## 24.3.26任务梳理

### 重构代码

把之前所有的MAP都换成了Response形式返回，这样更专业也更安全方便。

### 实现客户端认证

通过客户端id啊密码啊URL啊来进行很多很多验证，最后判断是否是注册过的客户端。。。

### 添加pojo和Mappar

为授权码开了个表来储存，并用pojo，mapper管理，其中信息包括，授权码（废话），用户id，用户允许的权限。

### 实现申请授权码

用户输入自己的账号密码，是否授权，授权哪些东西，来让客户端申请到一个授权码。

### 通过授权码拿到两个令牌

满足一定要求后可以获得一个五分钟的访问令牌和一个十四天的刷新令牌。具体作用不言而喻。这部分其实对我很简单，因为我自己写demo的时候就写了这个功能。。。

### 通过令牌获取信息

用令牌获取用户授权的信息，如果访问过期就刷新，如果刷新过期就重新登录。

### 你是不是很好奇我为什么今天写这么少？

嗯，其实是因为我写了一整天，写到沁苑11.断电还在写，现在以及00.10，我的电脑马上就要没电了嗯。。。。。

**今天的具体工作请看最上方的阶段二三详细功能介绍，基本上都是今天写的。**

### 24.3.26总结

嗯，花了一天的时间把核心功能写完了，虽然有不完善的地方，但是在有限的时间内我以及尽力把能力展现出来了。

这样一来阶段二就写完了，阶段三也是，不过后续**有时间的话**我可能还会再完善一些OAuth2.0服务的安全和完备性。

**时间：今天花了8个小时（5个小时写代码，1个小时写WorkLog，2个小时摸鱼嗯，，，，）。**

## 24.3.27任务梳理

### 了解OIDC

既然OIDC是建立再OAuth2.0的基础上的，我就去了解了一下OIDC到底做了什么。

### 实现OIDC

有了OAuth2.0 实现OIDC并不困难。

### 加入自己思想

既然是我自己手搓一个OAuth2.0这么好的机会，我就基于我的理解加入了一些我自己的想法，比如多次验证state，更多的用户选择等等。

虽然这些实现起来更麻烦，但是还是很有意思的。

### 编写openid-configuration.json

编写这个文档，告诉别人怎么用。但是由于是我自己手搓的，而且加入了自己的思想和最标准的OAuth2.0以及OIDC有些许不同，但是我想着**实习的本质目的是看看我们的学习能力和现有基础以及工作热情**，所以我觉得这些差别也无关紧要。

### 24.3.27总结

嗯，今天比昨天还短，主要是今天确实没干什么，课程太紧张了，明天开始做后续阶段和拓展内容。

**时间：今天花了一个半小时，半个小时了解OIDC，半个小时实现，半个小时写文档修bug。**

## 24.3.28任务梳理

### 建立各种表格以及其对应的pojo和mapper

表包括很多：

1. 动漫信息表
2. 动漫标签表（这部分是不做要求的，但是多的功能可以加分嘻嘻）
3. 用户追番表
4. 动漫状态表

搞这么多表的原因很简单：可以支持我做更多功能，功能越多分越高，进冰岩可能越大，嗯。**具体功能我会在全部写完后汇总一下，敬请期待吧！**

### 设立管理员制度

如果一个系统没有管理员不就乱套了吗？于是我设立了管理员注册，注册的管理员才能上传番剧，追番状态和tags。

### 编写上传番剧接口

番剧包括信息：

1. id
2. name
3. director
4. introduction
5. nums
6. URL（bilibili）

管理员可以上传番剧，需要以上信息。

### 编写获取番剧信息接口

一个接口获得该番剧的信息，必须登录才能用，如果你追番了，你还可以获得追番的信息。

### 编写模糊搜索番剧的接口

通过mysql实现了**模糊搜索**，返回所有满足的番剧信息。登录才能用

### 编写返回追番信息的接口

用户通过这个接口查看自己的追番信息，登录才能用

### 编写管理员上传状态的接口

如果五个状态不够用怎么办？直接在数据库里加？nonono！在这个系统里让管理员加一下就行了。

### 编写管理员上传tag的接口

没有对应的标签？联系管理员！！让他们上传。

我没有选择让用户自己上传tag的功能，因为那样太危险，敏感信息什么的不好处理（其实这是产品组柠檬的建议，我问她如果有一个平台允许你自己编辑作品标签和一个平台只用点击标签就行了，你选哪个？她选后者，具体原因是她说懒人会这么选，用户就会这么选）。

### 编写获取现在已有的状态和tags的接口

给前端写的。可以获得现在有哪些追番状态和tag，方便其显示在页面上。

### 编写追番接口

好了，准备工作做完了，开始追番吧，输入信息就可以追番了，注意，评论，打分和标签不是必须的信息。

### 编写判断是否已经追番的接口

还是给前端写的，毕竟已经追番和没有追番的页面应该不一样对吧！

### 修bug

出现了bug！！什么bug呢？奥，原来是没做数值检测就parseInt了。。。。。

给所有文件都做了这样的检测，确保这样的问题不再发生。

### 编写获取所有已经追了的番的接口

登录可用，返回所有已经追了的番剧，这样就可以做出一个以追番剧的页面，用户可以随时查看！！！

### 好啦，你发现今天内容多了起来不是吗？嗯，因为我今天有时间了

终于有时间大幅度推进进度了。。。。这样一来阶段五的基础功能就完成啦啦！！！

### 24.3.28总结

感谢你看我发疯。。。。。。。。。。虽然我觉得你们大概率不会看到这句话哈哈哈哈

我这一周课多的想死，基本上所有课余时间都在写这个了，所以精神状态有点不太好。。。。。。。。

好啦！明天开始写阶段五的提升阶段和阶段六！！！

悄悄说一句，我不喜欢阶段六。。。。。不是说她很难，而是我明明已经花了很多时间写了自己的系统，我不想再调用别人的接口。

**时间：今天花了7个小时，半个小时架构，5个小时编码，1个半小时摸鱼。。。。嘻嘻。**

## 24.3.29任务梳理

### 加入friend的pojo和mapper

实现一堆的pojo和Mapper具体在上方的代码框架里。

主要是要跟一堆表交互。

### 实现通过userid找到其追的番

通过userid找到其追的番，并返回番的id。这就可以点开一个人的页面然后点击查看追番，就可以访问这个接口，然后再根据相应的id去找到番剧的信息。

### 实现模糊搜索用户

通过模糊搜索找到用户。

### 实现发送好友请求的功能

用户可以发送好友请求，并且可以查看所有好友请求。

### 实现同意好友请求的功能

用户可以同意好友请求，并且可以查看所有好友。

### 实现拒绝好友请求的功能

用户可以拒绝好友请求，并且可以查看所有好友。

### 实现删除好友的功能

用户可以删除好友，并且可以查看所有好友。

### 实现查看好友在同一部番剧下的评论打分等信息的功能

用户可以查看好友在同一部番剧下的评论打分等信息。

### 实现获取bangumiCode的功能

接入bangumi的接口，实现获取token的功能

### 实现通过code获取token的功能

接入bangumi的接口，实现通过code获取token的功能。

### 实现通过token获取用户信息的功能

接入bangumi的接口，实现通过token获取用户信息的功能。

### 24.3.29总结

今天写了一天代码（摸了一天鱼）。。。。

最大的感触是不能在边看动漫边写代码了。。。。

本来12点之前就能写完的东西，因为看了13集迷宫饭写到了凌晨五点，，，，

**时间：今天花了15个小时，1个小时架构，5个小时编码，3个小时修bug，6个小时摸鱼。**
